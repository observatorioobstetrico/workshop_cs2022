<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Shiny</title>
    <meta charset="utf-8" />
    <meta name="author" content="Mariana Freitas e Rafael Sant’Ana Herzog" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <script src="libs/core-js/shim.min.js"></script>
    <script src="libs/react/react.min.js"></script>
    <script src="libs/react/react-dom.min.js"></script>
    <script src="libs/reactwidget/react-tools.js"></script>
    <script src="libs/htmlwidgets/htmlwidgets.js"></script>
    <script src="libs/reactable-binding/reactable.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
    <link rel="stylesheet" href="custom_css.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">

class: inverse, center, middle

background-image: url(img/logo.png)
background-position: 50% 15%
background-size: 30%

&lt;style&gt;
.middle-freeze{
padding-top: 12em;
}
&lt;/style&gt;

# &lt;br&gt;&lt;br&gt;Introdução ao Shiny

### Workshop Ciência de Dados 
### OOBr + Constat

---





&lt;style type="text/css"&gt;
pre {
  max-height: 330px;
  overflow-y: auto;
}
&lt;/style&gt;

### Sobre nós
.pull-left[
&lt;img src=img/perfil_Rafael.png width="330"&gt;
&lt;br&gt;&lt;br&gt;&lt;br&gt;Contato:

<svg aria-hidden="true" role="img" viewBox="0 0 512 512" style="height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:#0A1E3C;overflow:visible;position:relative;"><path d="M464 64C490.5 64 512 85.49 512 112C512 127.1 504.9 141.3 492.8 150.4L275.2 313.6C263.8 322.1 248.2 322.1 236.8 313.6L19.2 150.4C7.113 141.3 0 127.1 0 112C0 85.49 21.49 64 48 64H464zM217.6 339.2C240.4 356.3 271.6 356.3 294.4 339.2L512 176V384C512 419.3 483.3 448 448 448H64C28.65 448 0 419.3 0 384V176L217.6 339.2z"/></svg> &lt;a href="mailto:rafasantanah21@gmail.com"&gt;rafasantanah21@gmail.com&lt;/a&gt;

]

.pull-right[
&lt;img src=img/perfil_Mariana.png width="330"&gt;
&lt;br&gt;&lt;br&gt;&lt;br&gt;Contato:

<svg aria-hidden="true" role="img" viewBox="0 0 512 512" style="height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:#0A1E3C;overflow:visible;position:relative;"><path d="M464 64C490.5 64 512 85.49 512 112C512 127.1 504.9 141.3 492.8 150.4L275.2 313.6C263.8 322.1 248.2 322.1 236.8 313.6L19.2 150.4C7.113 141.3 0 127.1 0 112C0 85.49 21.49 64 48 64H464zM217.6 339.2C240.4 356.3 271.6 356.3 294.4 339.2L512 176V384C512 419.3 483.3 448 448 448H64C28.65 448 0 419.3 0 384V176L217.6 339.2z"/></svg> &lt;a href="mailto:mariana.c.freitas@edu.ufes.br"&gt;mariana.c.freitas@edu.ufes.br&lt;/a&gt;


]

---
class: middle

### Cronograma

1. Uma breve introdução ao Shiny: o que é e primeiros passos;

2. Interatividade: inputs e output;

3. Reatividade;

4. Tipos de layouts;

5. Construindo aplicativos com o .codigo[{shinydashboard}].

- Minicurso baseado no material do curso de Dashboards em Shiny I da [Curso-R](https://loja.curso-r.com/construindo-dashboards-i.html).

---
class:middle

### Sobre o OOBr

.pull-left[
- Plataforma interativa de **monitoramento**, **análises de dados públicos** (da saúde, socioeconômicos e ambientais) cientificamente embasadas e **disseminação de informações** relevantes na área da saúde materno-infantil. 

- Ser referência de informações acessíveis e confiáveis sobre saúde materno-infantil e ser um suporte importante para a tomada de decisões na área.

- Equipe multidisciplinar da UFES, USP e FACENS.

- Financiado pela Fundação Bill &amp; Melinda Gates, CNPq e FAPES.
]

.pull-right[
&lt;img src="img/logo2.png" width="100%" style="display: block; margin: auto;" /&gt;
]

---
class: middle

.pull-left[
### Painéis OOBr
&lt;img src="img/paineis.png" width="100%" style="display: block; margin: auto;" /&gt;
]

.pull-right[
### Livro e tutoriais OOBr
&lt;img src="img/tutoriais.png" width="100%" style="display: block; margin: auto;" /&gt;
]

.center[
#### <svg aria-hidden="true" role="img" viewBox="0 0 640 512" style="height:1em;width:1.25em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:#0A1E3C;overflow:visible;position:relative;"><path d="M172.5 131.1C228.1 75.51 320.5 75.51 376.1 131.1C426.1 181.1 433.5 260.8 392.4 318.3L391.3 319.9C381 334.2 361 337.6 346.7 327.3C332.3 317 328.9 297 339.2 282.7L340.3 281.1C363.2 249 359.6 205.1 331.7 177.2C300.3 145.8 249.2 145.8 217.7 177.2L105.5 289.5C73.99 320.1 73.99 372 105.5 403.5C133.3 431.4 177.3 435 209.3 412.1L210.9 410.1C225.3 400.7 245.3 404 255.5 418.4C265.8 432.8 262.5 452.8 248.1 463.1L246.5 464.2C188.1 505.3 110.2 498.7 60.21 448.8C3.741 392.3 3.741 300.7 60.21 244.3L172.5 131.1zM467.5 380C411 436.5 319.5 436.5 263 380C213 330 206.5 251.2 247.6 193.7L248.7 192.1C258.1 177.8 278.1 174.4 293.3 184.7C307.7 194.1 311.1 214.1 300.8 229.3L299.7 230.9C276.8 262.1 280.4 306.9 308.3 334.8C339.7 366.2 390.8 366.2 422.3 334.8L534.5 222.5C566 191 566 139.1 534.5 108.5C506.7 80.63 462.7 76.99 430.7 99.9L429.1 101C414.7 111.3 394.7 107.1 384.5 93.58C374.2 79.2 377.5 59.21 391.9 48.94L393.5 47.82C451 6.731 529.8 13.25 579.8 63.24C636.3 119.7 636.3 211.3 579.8 267.7L467.5 380z"/></svg> [https://observatorioobstetricobr.org](https://observatorioobstetricobr.org)
]

---
class: inverse, middle, center

## Introdução 

---
class: middle

### O que é o Shiny?

O Shiny é um pacote em R que nos permite criar páginas web interativas utilizando apenas códigos em R. Normalmente, para construir páginas web, nós precisaríamos de conhecimentos em HTML, JavaScript e CSS; a beleza do Shiny está em permitir a criação dessas páginas interativas a partir apenas do nosso conhecimento em R. 

Por não exigir conhecimento prévio de outras linguagens de programação, o Shiny democratiza o acesso ao desenvolvimento de páginas web, permitindo a criação de aplicativos bonitos e complexos a partir de um simples script em R.


.center[
&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="img/figura1.png" alt="Fonte: Curso-R." width="35%" /&gt;
&lt;p class="caption"&gt;Fonte: Curso-R.&lt;/p&gt;
&lt;/div&gt;
]

---
class: middle

### Primeiros passos

Por ser um pacote em R, precisamos, antes de qualquer coisa, instalar o Shiny em nossos computadores. Para isso, basta que executemos em nosso console do R o comando .codigo[install.packages("shiny")].

Para a criação de um novo aplicativo em Shiny, existem algumas maneiras possíveis de prosseguirmos. Uma delas é através da criação de um novo script em R e da utilização do *snippet* .codigo[shinyapp], disponível por padrão no RStudio. O script será automaticamente preenchido com um bloco de código contendo os componentes básicos de um aplicativo Shiny. 

.center[
&lt;img src="img/snippet.png" width="100%" style="display: block; margin: auto;" /&gt;
]

---
class: middle

### A estrutura básica de um aplicativo Shiny

Assim que criamos um aplicativo em Shiny, podemos perceber que existem três componentes básicos: 

- Um objeto chamado .codigo[ui] (interface do usuário); 
- Uma função chamada .codigo[server] (servidor);
- Uma chamada da função .codigo[shinyApp()], responsável por juntar a UI e o servidor e criar o aplicativo Shiny. 
 
Exceto algumas poucas exceções, a grande maioria dos aplicativos em Shiny seguirá essa mesma estrutura.


```r
library(shiny)

ui &lt;- fluidPage(
  
)

server &lt;- function(input, output, session) {
  
}

shinyApp(ui, server)
```

&lt;img src="shiny_files/figure-html/unnamed-chunk-7-1.png" width="100%" /&gt;

---
class: middle

### UI: a cara do seu aplicativo

É dentro da UI que decidiremos quais elementos serão mostrados ao usuário e onde eles estarão dispostos. Ela é a “cara” do nosso aplicativo. Nesse objeto, não vamos fazer nenhuma manipulação de dados, análises, criação de gráficos ou qualquer outra coisa do tipo. Iremos apenas organizar a interface para que ela possa ser apresentada ao usuário final. 

Como considerações iniciais sobre a UI, podemos dizer que:

- Tudo que colocaremos dentro da UI deve estar dentro da função .codigo[fluidPage()]. Essa função cria uma página fluida, que nada mais é do que uma página em branco que pode ser customizada de acordo com a nossa vontade;

- Uma fluid page pode ser dividida em linhas, por meio da função .codigo[fluidRow()];

- Uma fluid row pode ser dividida em colunas, por meio da função .codigo[column()].  

Além disso, tudo o que criarmos dentro da UI retornará um código HTML. Dessa forma, estamos, mesmo que sem saber, utilizando funções em R para "programar" em HTML.


```r
ui &lt;- fluidPage("O meu primeiro aplicativo")
#&gt; &lt;div class="container-fluid"&gt;O meu primeiro aplicativo&lt;/div&gt;
```

---
class: middle

### Um exemplo de UI

Um exemplo da UI de um aplicativo básico pode ser visto abaixo. O app permite a seleção de duas variáveis e apresenta o gráfico de dispersão delas.

.center[
&lt;img src="img/ui.png" width="100%" style="display: block; margin: auto;" /&gt;
]

---
class: middle

### Server: o que está por trás dos panos

O .codigo[server()] é uma função responsável por realizar todo o processamento dos dados que o seu aplicativo precisa. Sempre que queremos manipular bases de dados, gerar tabelas, gráficos, mapas e qualquer outro tipo de visualização, é o servidor que utilizaremos. E tudo o que criarmos aqui e que queiramos que seja mostrado ao usuário será referenciado na UI. 

Essa função recebe três argumentos: 

- .codigo[input]: uma lista com todos os parâmetros que o usuário pode mexer;
-	.codigo[output]: uma lista com todas as visualizações que vamos mostrar para o usuário;
-	.codigo[session]: uma lista com informações da sessão que está rodando o aplicativo.

É importante ressaltar que todas as três listas serão criadas automaticamente quando rodarmos o aplicativo. Mas somos nós quem definiremos os elementos que estarão dentro das listas .codigo[input] e .codigo[output].

---
class: middle

### Rodando o aplicativo

Para rodar um app, podemos usar três métodos diferentes:

-	Podemos clicar no botão Run App, que aparece no canto superior direito do RStudio quando salvamos arquivo que contém o app;

.center[
&lt;img src="img/runapp.png" width="80%" style="display: block; margin: auto;" /&gt;
]

-	Podemos rodar o script que contém o app através do atalho .codigo[CTRL + SHIFT + ENTER];

-	Podemos utilizar a função .codigo[runApp()], passando como argumento o caminho até o arquivo que contém o app.

---
class: middle

### Sessão ocupada

É importante lembrar que, enquanto o seu aplicativo está aberto, a sessão do R estará ocupada. Com isso, não conseguiremos rodar qualquer tipo de código nesse meio tempo. Isso acontece porque todo aplicativo Shiny precisa de uma sessão de R rodando por trás. Essa sessão fornece a comunicação da UI com o servidor e é responsável por atualizar as visualizações apresentadas na UI sempre que alguém interagir com o app.


Para desocupar a sessão, basta que fechemos o aplicativo, seja diretamente, seja pelo botão .codigo[STOP], no console do RStudio, ou apertando a tecla .codigo[ESC] com o RStudio aberto.


.center[
&lt;img src="img/stop.png" width="80%" style="display: block; margin: auto;" /&gt;
]

---
class: inverse, middle, center

## Interatividade: inputs e outputs

---
class: middle

### Inputs e Outputs

Um dos principais motivos de se criar um aplicativo Shiny é permitir a interação entre o usuário e o painel de visualização. Essa interatividade é proporcionada através da criação de **inputs** e **outputs**.

.center[
&lt;img src="img/ui.png" width="100%" style="display: block; margin: auto;" /&gt;
]

---
class: middle

### Inputs: as entradas do aplicativo


Os inputs representam as entradas do nosso aplicativo, isto é, a maneira como o usuário pode fornecer informações. Essas informações podem ser números, textos, datas, arquivos ou até mesmo cliques em um botão, e serão utilizadas pelo servidor para realizar manipulações de dados e construção de visualizações.

Os inputs de um aplicativo são criados dentro da UI, e as funções que utilizamos para criá-los seguem um padrão: em geral, elas são da forma &lt;code style = "color: #0A1E3C"&gt;&amp;ast;&lt;/code&gt;.codigo[Input()], onde o asterisco representa o tipo de input em questão. Para inputs que são botões, o padrão dos nomes das funções costuma ser &lt;code style = "color: #0A1E3C"&gt;&amp;ast;&lt;/code&gt;.codigo[Button()].

Todas as funções que criam inputs têm o mesmo primeiro argumento: .codigo[inputId]. Esse é um identificador, **que deve ser único** e que será utilizado para acessar cada input dentro do servidor.

Se dentro da nossa UI existe um input cujo .codigo[inputId] seja *"texto"*, podemos acessar esse input dentro da função .codigo[server()] através do código .codigo[input$texto]. Todos os inputs ficarão dentro da lista .codigo[input].

.center[
#### <svg aria-hidden="true" role="img" viewBox="0 0 640 512" style="height:1em;width:1.25em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:#0A1E3C;overflow:visible;position:relative;"><path d="M172.5 131.1C228.1 75.51 320.5 75.51 376.1 131.1C426.1 181.1 433.5 260.8 392.4 318.3L391.3 319.9C381 334.2 361 337.6 346.7 327.3C332.3 317 328.9 297 339.2 282.7L340.3 281.1C363.2 249 359.6 205.1 331.7 177.2C300.3 145.8 249.2 145.8 217.7 177.2L105.5 289.5C73.99 320.1 73.99 372 105.5 403.5C133.3 431.4 177.3 435 209.3 412.1L210.9 410.1C225.3 400.7 245.3 404 255.5 418.4C265.8 432.8 262.5 452.8 248.1 463.1L246.5 464.2C188.1 505.3 110.2 498.7 60.21 448.8C3.741 392.3 3.741 300.7 60.21 244.3L172.5 131.1zM467.5 380C411 436.5 319.5 436.5 263 380C213 330 206.5 251.2 247.6 193.7L248.7 192.1C258.1 177.8 278.1 174.4 293.3 184.7C307.7 194.1 311.1 214.1 300.8 229.3L299.7 230.9C276.8 262.1 280.4 306.9 308.3 334.8C339.7 366.2 390.8 366.2 422.3 334.8L534.5 222.5C566 191 566 139.1 534.5 108.5C506.7 80.63 462.7 76.99 430.7 99.9L429.1 101C414.7 111.3 394.7 107.1 384.5 93.58C374.2 79.2 377.5 59.21 391.9 48.94L393.5 47.82C451 6.731 529.8 13.25 579.8 63.24C636.3 119.7 636.3 211.3 579.8 267.7L467.5 380z"/></svg> [https://shiny.rstudio.com/gallery/widget-gallery.html](https://shiny.rstudio.com/gallery/widget-gallery.html)
]

---
class: middle

### No <svg aria-hidden="true" role="img" viewBox="0 0 581 512" style="height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:#0A1E3C;overflow:visible;position:relative;"><path d="M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z"/></svg>

Vamos construir parte da UI do aplicativo abaixo. Podemos visualizar esse aplicativo através [deste link](https://rafasantanah.shinyapps.io/meu-primeiro-app/).

.center[
&lt;img src="img/ui.png" width="100%" style="display: block; margin: auto;" /&gt;
]

---
class: middle

### Outputs: as saídas do aplicativo

Os outputs representam as saídas do nosso aplicativo, isto é, tudo que queremos que seja mostrado para o usuário. Essas saídas podem ser tabelas, gráficos, mapas, texto, imagens e vários outros elementos.

Os outputs são **definidos na UI** e **criados no servidor**. Dentro da UI, cada tipo de output é definido por uma função do que segue o padrão .codigo[\*Output()], onde o asterisco representa o tipo de visualização que queremos definir. As principais funções dessa família, bem como as visualizações que definimos com elas, podem ser vistas abaixo:

<div id="htmlwidget-1fc1ea1494ba7e1eb9e1" class="reactable html-widget" style="width:auto;height:auto;"></div>
<script type="application/json" data-for="htmlwidget-1fc1ea1494ba7e1eb9e1">{"x":{"tag":{"name":"Reactable","attribs":{"data":{"funcao":["plotOutput()","tableOutput()","textOutput"],"visualizacoes":["Gráficos","Tabelas","Textos"]},"columns":[{"accessor":"funcao","name":"Função","type":"character"},{"accessor":"visualizacoes","name":"Visualizações definidas","type":"character"}],"sortable":false,"defaultPageSize":10,"paginationType":"numbers","showPageInfo":true,"minRows":1,"dataKey":"84ffd2728853a0fdf9f3290ad76a2b64"},"children":[]},"class":"reactR_markup"},"evals":[],"jsHooks":[]}</script>

Todas as funções utilizadas para definirmos outputs na UI recebem como primeiro argumento o .codigo[outputId]. Esse é um identificador **que deve ser único para cada output** e que será utilizado dentro do servidor para se acessar o output correspondente, através do código .codigo[output$id_do_output]. Todos os outputs ficarão dentro da lista .codigo[output].

---

### Outputs: as funções render

Para criarmos, de fato, um output, precisamos das funções do tipo .codigo[render\*()], onde o asterisco representa o tipo de output que estamos criando. É dentro dessas funções que escrevemos o código necessário para a criação dos outputs. 

As funções do tipo .codigo[render\*()] são responsáveis por conectar as visualizações definidas na UI com seus códigos construídos dentro do servidor. Na grande maioria dos casos, para mostrarmos um output ao usuário, teremos um par de funções formado por:

- uma função do tipo .codigo[visualizacaoOutput()], na UI;
- uma função do tipo .codigo[renderVisualizacao()], no servidor. 

Veja abaixo as principais funções .codigo[render\*()] e como elas se comunicam com as funções &lt;code style = "color: #0A1E3C"&gt;&amp;ast;&lt;/code&gt;.codigo[Output()].

<div id="htmlwidget-b84eae388d6a75e0d3a0" class="reactable html-widget" style="width:auto;height:auto;"></div>
<script type="application/json" data-for="htmlwidget-b84eae388d6a75e0d3a0">{"x":{"tag":{"name":"Reactable","attribs":{"data":{"ui":["plotOutput()","tableOutput()","textOutput"],"servidor":["renderPlot()","renderTable()","renderText()"]},"columns":[{"accessor":"ui","name":"Na UI","type":"character"},{"accessor":"servidor","name":"No servidor","type":"character"}],"sortable":false,"defaultPageSize":10,"paginationType":"numbers","showPageInfo":true,"minRows":1,"dataKey":"ffba1ff3969ac657a637a2cbec1ae9a4"},"children":[]},"class":"reactR_markup"},"evals":[],"jsHooks":[]}</script>

---
class: top

### Acessando outputs no servidor

Abaixo, temos um exemplo de como acessar um output definido na UI dentro do servidor. 

.panelset[

.panel[
.panel-name[Aplicativo]

&lt;img src="img/ui_2.png" width="90%" style="display: block; margin: auto;" /&gt;

]

.panel[
.panel-name[Código]


```r
library(shiny)

ui &lt;- fluidPage(
  titlePanel("Um gráfico de dispersão"),
  hr(),
  "Este é um exemplo de como acessar um output definido na UI dentro do servidor.",
  plotOutput(outputId = "grafico")
)

server &lt;- function(input, output, session) {
  output$grafico &lt;- renderPlot({
    plot(x = mtcars$wt,
         y = mtcars$mpg,
         main = "Gráfico de dispersão entre wt e mpg",
         xlab = "wt",
         ylab = "mpg",
         pch = 19)
  })
}

shinyApp(ui, server)
```

]

]

---
class: middle

### No <svg aria-hidden="true" role="img" viewBox="0 0 581 512" style="height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:#0A1E3C;overflow:visible;position:relative;"><path d="M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z"/></svg>

Vamos, agora, completar a construção do aplicativo que iniciamos anteriormente, definindo o gráfico de dispersão dentro da UI e escrevendo o código necessário para a sua criação dentro do servidor. Novamente, podemos visualizar esse aplicativo através [deste link](https://rafasantanah.shinyapps.io/meu-primeiro-app/).

.center[
&lt;img src="img/ui.png" width="100%" style="display: block; margin: auto;" /&gt;
]

---
class: inverse, middle, center

## Reatividade

---
class:top

### Dois diferentes paradigmas de programação

Para entendermos o funcionamento de um aplicativo Shiny, é necessário que conheçamos a diferença entre dois importantes paradigmas de programação: a **programação imperativa** e a **programação declarativa**.

--

- Na **programação imperativa**, nós precisamos descrever detalhadamente o passo a passo de um processo que a máquina deve executar, ou seja, as instruções são passadas por meio de códigos que devem ser executados **sequencialmente**. Em outras palavras, o foco está no **que** um programa deve realizar, e **como** esse processo deve ser executado.

--

- Por outro lado, na **programação declarativa**, o foco está apenas no **que** deve ser executado: nós apenas demonstramos o resultado esperado do código, sem nos preocuparmos com forma com a qual o processo será executado. Ou seja, a decisão de **quando** ou **como** executar o processo dependerá de algum outro mecanismo. E esse é o estilo de programação que nós utilizamos dentro do Shiny.   

--

A programação declarativa funciona como uma receita: nossos códigos descrevem aquilo queremos que seja realizado, e o Shiny decide a ordem e o momento em que esses códigos serão avaliados. O elemento responsável pela realização desse processo é o chamado **diagrama de reatividade**.

---
class: middle

### Diagrama de reatividade

O diagrama de reatividade é um conjunto de dependências que descreve como inputs e outputs estão conectados, sendo responsável por definir a ordem de execução dos códigos que escrevemos dentro do servidor. 

No aplicativo criado anteriormente, toda alteração que fazíamos em qualquer um dos inputs resultava automaticamente em uma atualização do gráfico que estávamos criando. Isso acontecia porque o Shiny, por meio do diagrama de reatividade, era capaz de reconhecer que o output do gráfico era **dependente** de todos os três inputs existentes no aplicativo. Um esquema do diagrama de reatividade do aplicativo pode ser visto abaixo.

.center[
&lt;img src="img/diagrama.png" width="80%" style="display: block; margin: auto;" /&gt;
]

---
class: top

### A estrutura de um diagrama de reatividade

O diagrama de reatividade de um aplicativo Shiny possui três estruturas principais: os **valores reativos**, os **observers** e as **expressões reativas**.

--

- Os **valores reativos** são as chamadas **fontes de reatividade**, e são o ponto inicial do diagrama de reatividade. Eles guardam as informações que vêm da UI e disparam sinais de alerta sempre que essas informações mudam. Os valores reativos podem ser lidos por outros objetos reativos, e os exemplos mais comuns deles são aqueles dentro da lista .codigo[input].

--

- Os **observers** são o ponto final do diagrama de reatividade. Eles guardam o código de cada output, e recebem os sinais de alerta enviados pelos inputs para avaliar a necessidade de se recalcular um output. Os observers podem ler valores reativos e expressões reativas, sendo os exemplos mais comuns deles as funções .codigo[render\*()].

--

- Por fim, as **expressões reativas** são os chamados **condutores de reatividade**. Ela são capazes de ler valores reativos, realizar alguma manipulação e devolver um resultado que é, também, um valor reativo, e que por isso pode ser utilizado em um observer. Para criar expressões reativas, podemos utilizar as funções .codigo[reactive()] e .codigo[eventReactive()].

--

.center[
&lt;img src="img/diagrama2.png" width="90%" style="display: block; margin: auto;" /&gt;
]

---
class: top

### A função reactive()

Vamos utilizar a função .codigo[reactive()] para tornar o aplicativo abaixo mais eficiente. Tudo o que precisamos fornecer a essa função é o código da expressão que queremos tornar reativa. É importante dizer que para acessar o valor de uma expressão reativa, precisamos usar parênteses após seu nome. O app pode ser visualizado através [deste link](https://rafaelsherzog.shinyapps.io/02-reactive/).

.panelset[

.panel[
.panel-name[UI]


```r
ui &lt;- fluidPage(
  titlePanel("Entendendo a necessidade de uma expressão reativa"),
  hr(),
  fluidRow(
    column(
      width = 4,
      selectInput(
        inputId = "cilindros",
        label = "Selecione o número de cilindros do motor:",
        choices = sort(unique(mtcars$cyl))
      )
    ),
    column(
      width = 4,
      selectInput(
        inputId = "eixo_x",
        label = "Selecione a variável do eixo x do gráfico:",
        choices = names(mtcars)
      )
    ),
    column(
      width = 4,
      selectInput(
        inputId = "eixo_y",
        label = "Selecione a variável do eixo y do gráfico:",
        choices = names(mtcars)
      )
    )
  ), 
  br(),
  fluidRow(
    column(
      width = 6,
      tableOutput(outputId = "tabela")
    ),
    column(
      width = 6,
      plotOutput(outputId = "grafico")
    )
  )
)
```

]

.panel[
.panel-name[Servidor]


```r
server &lt;- function(input, output, session) {
  mtcars_filtrada &lt;- reactive({
    mtcars |&gt;
      filter(cyl == input$cilindros)
  })
  
  output$tabela &lt;- renderTable(mtcars_filtrada(), rownames = TRUE)
  
  output$grafico &lt;- renderPlot({
    mtcars_filtrada() |&gt;
      ggplot(mapping = aes_string(x = input$eixo_x, y = input$eixo_y)) +
      geom_point()
  })
}
shinyApp(ui, server)
```


]

]


---
class: middle

### A função eventReactive()

Caso seja de nosso interesse controlar o momento em que um observer ou uma expressão reativa seja atualizado, podemos utilizar a função .codigo[eventReactive()]. Essa função permite que um certo bloco de código só seja avaliado quando uma certa ação for realizada. Assim como no caso anterior, a função .codigo[eventReactive()] também retorna uma expressão reativa, e por isso precisamos utilizar parênteses para acessar o seu valor. 

Vamos, agora, utilizar essa função para forçar que a tabela e o gráfico construídos no exemplo anterior só sejam atualizados quando o usuário clicar no botão **"Atualizar a tabela e o gráfico"**, como está na imagem abaixo. O aplicativo completo pode ser acessado por meio [deste link](https://rafasantanah.shinyapps.io/event-reactive/).

.center[
&lt;img src="img/botao_atualizar.png" width="100%" style="display: block; margin: auto;" /&gt;
]


---
class: middle

### Contexto reativo

Valores reativos e expressões reativas só podem ser utilizados dentro de um contexto reativo. Esse tipo de ambiente é criado, por exemplo, pelas funções .codigo[render\*()] e pelas funções .codigo[reactive()] e .codigo[eventReactive()]. Dessa forma, precisamos levar em consideração que só podemos acessar os valores da lista .codigo[input] ou as expressões reativas que criamos quando estamos dentro de um contexto reativo.

&lt;b style = "color: red"&gt; Errado &lt;/b&gt;


```r
# server
output$tabela &lt;- table(mtcars[mtcars$cyl == input$cilindros, ])
#&gt; Error : Can't access reactive value 'cilindros' outside of reactive consumer.
```

&lt;b style = "color: green"&gt; Certo &lt;/b&gt;


```r
# server
output$tabela &lt;- renderTable(mtcars[mtcars$cyl == input$cilindros, ])
```


---
class: inverse, middle, center

## Layouts

---
class: middle

### HTML e Tags HTML

De forma resumida, o HTML é uma **linguagem de marcação**, ou seja, é um tipo de documento que contém um texto simples e um conjunto de instruções para formatar partes específicas do texto. Dentro do HTML, essas instruções de formatação são chamadas de *tags*. Como foi dito anteriormente, a UI nada mais é do que um grande bloco de código HTML. Dessa forma, podemos utilizar as tags dentro de um aplicativo Shiny para formatar os elementos da página a nosso gosto.

O pacote .codigo[{shiny}] possui uma série de funções que simulam as tags HTML. Além disso, todas as tags existentes podem ser acessadas através da lista .codigo[tags], disponível dentro do pacote. As principais funções que utilizamos, bem como o que fazem, podem ser vistas abaixo:


&lt;div class="figure"&gt;
<div id="htmlwidget-8347d353297accc20be8" class="reactable html-widget" style="width:auto;height:200px;"></div>
<script type="application/json" data-for="htmlwidget-8347d353297accc20be8">{"x":{"tag":{"name":"Reactable","attribs":{"data":{"funcao":["a()","hr()","br()","h1(), ..., h6()","img()","p()","em()","strong()"],"acao":["cria um hiperlink","cria uma linha horizontal","insere uma quebra de linha","cria títulos","insere uma imagem","cria um parágrafo","formata o texto em itálico","formata o texto em negrito"]},"columns":[{"accessor":"funcao","name":"Função","type":"character"},{"accessor":"acao","name":"Para que serve","type":"character"}],"sortable":false,"defaultPageSize":10,"paginationType":"numbers","showPageInfo":true,"minRows":1,"height":"200px","dataKey":"e7a0b141379a322a008917f3458846a3"},"children":[]},"class":"reactR_markup"},"evals":[],"jsHooks":[]}</script>
&lt;p class="caption"&gt;Fonte: Curso-R.&lt;/p&gt;
&lt;/div&gt;



---
class: middle

### O que está por trás do layout de um app

O layout de um aplicativo Shiny segue um framework chamado de Bootstrap. O Bootstrap é um conjunto de códigos HTML, CSS e JavaScript que definem como o layout de um app deve funcionar. Algumas definições do Bootstrap são:

1. Os elementos serão dispostos primeiramente em linhas;
2. Cada nova linha será colocada embaixo da anterior;
3. Cada linha pode ser dividida em colunas;
4. O comprimento da página será dividido em 12 unidades, independentemente do tamanho da tela.

.center[
&lt;img src="img/bootstrap.png" width="100%" style="display: block; margin: auto;" /&gt;
&lt;b&gt; Fonte &lt;/b&gt;: &lt;a href = https://dzone.com/articles/working-with-bootstrap-4-grid-system-for-creating&gt; https://dzone.com/articles/working-with-bootstrap-4-grid-system-for-creating &lt;/a&gt;
]

---
class: middle

### Linhas e colunas

Como dissemos no início da apresentação, podemos criar novas linhas dentro da UI através da função .codigo[fluidRow()]. Tudo aquilo que queremos que seja mostrado dentro de uma dada linha deve ser colocado dentro da fluid row correspondente.

Além disso, para criar colunas dentro de uma linha, utilizamos a função .codigo[column()]. Essa função tem dois argumentos importantes: .codigo[width] e .codigo[offset]. Como já vimos ao longo dos exemplos, temos que:

- o argumento .codigo[width] determina o comprimento da coluna, que varia de 1 a 12; 
- o argumento .codigo[offset] indica quantas unidades gostaríamos de "pular" antes de começar a coluna em questão. 

Um exemplo da utilização dessas funções pode ser visto abaixo.

.center[
&lt;img src="img/linhas.png" width="90%" style="display: block; margin: auto;" /&gt;
&lt;b&gt; Fonte &lt;/b&gt;: Curso-R.
]

---
class: middle

### Layouts

Dentro do pacote .codigo[{shiny}], podemos encontrar algumas funções que nos permitem utilizar layouts um pouco mais complexos. Nessa apresentação, iremos falar sobre:

- o .codigo[sidebarLayout()], para criar um aplicativo que contenha uma barra lateral, na qual colocaremos inputs, e uma área principal, na qual colocaremos outputs;

- o .codigo[tabsetPanel()], para dividir a área principal de um sidebarLayout em várias abas;

- e a .codigo[navbarPage()], para criar um aplicativo com várias páginas. 

Além disso, existem alguns pacotes que permitem a construção de aplicativos com outros tipos de layouts. Falaremos sobre um deles, o .codigo[{shinydashboard}], mais adiante.

---
class: middle

### sidebarLayout: um exemplo 

Transformando o layout do aplicativo criado anteriormente em um sidebarLayout, teríamos o seguinte resultado, que pode ser acessado através [deste link](https://rafaelsherzog.shinyapps.io/04-sidebarLayout/):

.center[
&lt;img src="img/sidebar2.png" width="90%" style="display: block; margin: auto;" /&gt;
]

---
class: middle

### sidebarLayout: entendendo o código

A estrutura da UI de um aplicativo construído utilizando o sidebarLayout é a seguinte:

.panelset[

.panel[
.panel-name[1]

Toda a UI estará dentro da função .codigo[fluidPage()]:


```r
*ui &lt;- fluidPage(
  titlePanel(),
  sidebarLayout(
    sidebarPanel(),
    mainPanel()
  )
*)
```

]

.panel[
.panel-name[2]

O título do aplicativo é definido através da função .codigo[titlePanel()]:


```r
ui &lt;- fluidPage(
* titlePanel(),
  sidebarLayout(
    sidebarPanel(),
    mainPanel()
  )
)
```

]

.panel[
.panel-name[3]

Definimos que queremos utilizar esse tipo de layout através da função .codigo[sidebarLayout()]:


```r
ui &lt;- fluidPage(
  titlePanel(),
* sidebarLayout(
    sidebarPanel(),
    mainPanel()
* )
)
```

]

.panel[
.panel-name[4]

Dentro de .codigo[sidebarLayout()], criamos a barra lateral através da função .codigo[sidebarPanel()];


```r
ui &lt;- fluidPage(
  titlePanel(),
  sidebarLayout(
*   sidebarPanel(),
    mainPanel()
  )
)
```

]

.panel[
.panel-name[5]

Também dentro de .codigo[sidebarLayout()], criamos a área principal do painel através da função .codigo[mainPanel()].


```r
ui &lt;- fluidPage(
  titlePanel(),
  sidebarLayout(
    sidebarPanel(),
*   mainPanel()
  )
)
```

]
]

---
class: middle

### sidebarLayout: entendendo o código

Vamos, agora, passar para a montagem do aplicativo mostrado. Como vimos, todos os elementos do layout são colocados dentro da função .codigo[fluidPage()]:


```r
*ui &lt;- fluidPage(
  titlePanel(title = "Um aplicativo usando o sidebarLayout"),
  hr(),
  sidebarLayout(
    sidebarPanel(
      selectInput(inputId = "cilindros", label = "Selecione o número de cilindros do motor:", choices = sort(unique(mtcars$cyl))),
      selectInput(inputId = "eixo_x", label = "Selecione a variável do eixo x do gráfico:", choices = names(mtcars)),
      selectInput(inputId = "eixo_y", label = "Selecione a variável do eixo y do gráfico:", choices = names(mtcars)),
      actionButton(inputId = "atualizar", label = "Atualizar a tabela e o gráfico")
    ),
    mainPanel(
      tableOutput(outputId = "tabela"),
      plotOutput(outputId = "grafico")
    )
  )
*)
```


---
class: middle

### sidebarLayout: entendendo o código

Atribuímos ao aplicativo o título "Um aplicativo usando o sidebarLayout" através da função .codigo[titlePanel()]:


```r
ui &lt;- fluidPage(
* titlePanel(title = "Um aplicativo usando o sidebarLayout"),
  hr(),
  sidebarLayout(
    sidebarPanel(
      selectInput(inputId = "cilindros", label = "Selecione o número de cilindros do motor:", choices = sort(unique(mtcars$cyl))),
      selectInput(inputId = "eixo_x", label = "Selecione a variável do eixo x do gráfico:", choices = names(mtcars)),
      selectInput(inputId = "eixo_y", label = "Selecione a variável do eixo y do gráfico:", choices = names(mtcars)),
      actionButton(inputId = "atualizar", label = "Atualizar a tabela e o gráfico")
    ),
    mainPanel(
      tableOutput(outputId = "tabela"),
      plotOutput(outputId = "grafico")
    )
  )
)
```

---
class: middle

### sidebarLayout: entendendo o código

Definimos que queremos utilizar esse layout através da função .codigo[sidebarLayout()]: 


```r
ui &lt;- fluidPage(
  titlePanel(title = "Um aplicativo usando o sidebarLayout"),
  hr(),
* sidebarLayout(
    sidebarPanel(
      selectInput(inputId = "cilindros", label = "Selecione o número de cilindros do motor:", choices = sort(unique(mtcars$cyl))),
      selectInput(inputId = "eixo_x", label = "Selecione a variável do eixo x do gráfico:", choices = names(mtcars)),
      selectInput(inputId = "eixo_y", label = "Selecione a variável do eixo y do gráfico:", choices = names(mtcars)),
      actionButton(inputId = "atualizar", label = "Atualizar a tabela e o gráfico")
    ),
    mainPanel(
      tableOutput(outputId = "tabela"),
      plotOutput(outputId = "grafico")
    )
* )
)
```

---
class: middle

### sidebarLayout: entendendo o código

Criamos a barra lateral do painel através da função .codigo[sidebarPanel()]: 


```r
ui &lt;- fluidPage(
  titlePanel(title = "Um aplicativo usando o sidebarLayout"),
  hr(),
  sidebarLayout(
*   sidebarPanel(
      selectInput(inputId = "cilindros", label = "Selecione o número de cilindros do motor:", choices = sort(unique(mtcars$cyl))),
      selectInput(inputId = "eixo_x", label = "Selecione a variável do eixo x do gráfico:", choices = names(mtcars)),
      selectInput(inputId = "eixo_y", label = "Selecione a variável do eixo y do gráfico:", choices = names(mtcars)),
      actionButton(inputId = "atualizar", label = "Atualizar a tabela e o gráfico")
*   ),
    mainPanel(
      tableOutput(outputId = "tabela"),
      plotOutput(outputId = "grafico")
    )
  )
)
```

---
class: middle

### sidebarLayout: entendendo o código

Dentro da função .codigo[sidebarPanel()], definimos tudo aquilo que queremos que esteja na barra lateral do painel (nesse caso, temos três select inputs e um action button): 


```r
ui &lt;- fluidPage(
  titlePanel(title = "Um aplicativo usando o sidebarLayout"),
  hr(),
  sidebarLayout(
    sidebarPanel(
*     selectInput(inputId = "cilindros", label = "Selecione o número de cilindros do motor:", choices = sort(unique(mtcars$cyl))),
*     selectInput(inputId = "eixo_x", label = "Selecione a variável do eixo x do gráfico:", choices = names(mtcars)),
*     selectInput(inputId = "eixo_y", label = "Selecione a variável do eixo y do gráfico:", choices = names(mtcars)),
*     actionButton(inputId = "atualizar", label = "Atualizar a tabela e o gráfico")
    ),
    mainPanel(
      tableOutput(outputId = "tabela"),
      plotOutput(outputId = "grafico")
    )
  )
)
```


---
class: middle

### sidebarLayout: entendendo o código

Criamos a área principal do painel através da função .codigo[mainPanel()]: 


```r
ui &lt;- fluidPage(
  titlePanel("Um aplicativo usando o sidebarLayout"),
  hr(),
  sidebarLayout(
    sidebarPanel(
      selectInput(inputId = "cilindros", label = "Selecione o número de cilindros do motor:", choices = sort(unique(mtcars$cyl))),
      selectInput(inputId = "eixo_x", label = "Selecione a variável do eixo x do gráfico:", choices = names(mtcars)),
      selectInput(inputId = "eixo_y", label = "Selecione a variável do eixo y do gráfico:", choices = names(mtcars)),
      actionButton(inputId = "atualizar", label = "Atualizar a tabela e o gráfico")
    ),
*   mainPanel(
      tableOutput(outputId = "tabela"),
      plotOutput(outputId = "grafico")
*   )
  )
)
```

---
class: middle

### sidebarLayout: entendendo o código

Dentro da função .codigo[mainPanel()], definimos tudo aquilo que queremos que esteja na área principal do painel (nesse caso, temos uma tabela e um gráfico): 


```r
ui &lt;- fluidPage(
  titlePanel("Um aplicativo usando o sidebarLayout"),
  hr(),
  sidebarLayout(
    sidebarPanel(
      selectInput(inputId = "cilindros", label = "Selecione o número de cilindros do motor:", choices = sort(unique(mtcars$cyl))),
      selectInput(inputId = "eixo_x", label = "Selecione a variável do eixo x do gráfico:", choices = names(mtcars)),
      selectInput(inputId = "eixo_y", label = "Selecione a variável do eixo y do gráfico:", choices = names(mtcars)),
      actionButton(inputId = "atualizar", label = "Atualizar a tabela e o gráfico")
    ),
    mainPanel(
*     tableOutput(outputId = "tabela"),
*     plotOutput(outputId = "grafico")
    )
  )
)
```

---
class: middle

### sidebarLayout: entendendo o código

Não precisamos fazer nada de diferente dentro do servidor. 


```r
server &lt;- function(input, output, session) {
  mtcars_filtrada &lt;- reactive({
    mtcars |&gt;
      filter(cyl == input$cilindros)
  })
  
  tabela_atualizada &lt;- eventReactive(input$atualizar, {
    mtcars_filtrada()
  })
  
  output$tabela &lt;- renderTable(tabela_atualizada(), rownames = TRUE)
  
  grafico_atualizado &lt;- eventReactive(input$atualizar, {
    mtcars_filtrada() |&gt;
      ggplot(mapping = aes_string(x = input$eixo_x, y = input$eixo_y)) +
      geom_point()
  })
  
  output$grafico &lt;- renderPlot(grafico_atualizado())
}
```


---
class: middle

### sidebarLayout: No <svg aria-hidden="true" role="img" viewBox="0 0 581 512" style="height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:#0A1E3C;overflow:visible;position:relative;"><path d="M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z"/></svg>

Vamos ao R para visualizar melhor a construção de um sidebarLayout.

---
class: middle

### tabsetPanel: um exemplo 

O tabsetPanel não é um layout completo: nós podemos implementá-lo dentro de algum tipo de layout para dividir a área principal do aplicativo em mais de uma aba. Implementando o tabsetPanel no sidebarLayout do aplicativo criado anteriormente, teríamos o seguinte resultado, que podemos acessar através [deste link](https://rafaelsherzog.shinyapps.io/05-tabsetPanel/):

.panelset[

.panel[
.panel-name[Primeira aba]

.center[
&lt;img src="img/tabset1.png" width="90%" style="display: block; margin: auto;" /&gt;
]
]

.panel[
.panel-name[Segunda aba]

.center[
&lt;img src="img/tabset2.png" width="95%" style="display: block; margin: auto;" /&gt;
]

]


]


---
class: middle

### tabsetPanel: entendendo o código

Em comparação com o aplicativo criado utilizando apenas o sidebarLayout, a única diferença que temos no código da UI está dentro da função .codigo[mainPanel()]. Observe que agora estamos utilizando, dentro de .codigo[mainPanel()], a função .codigo[tabsetPanel()]. Essa é a função responsável por dividir as visualizações dos outputs em abas separadas.


```r
ui &lt;- fluidPage(
  titlePanel("Um aplicativo usando o tabsetPanel junto do sidebarLayout"),
  hr(),
  sidebarLayout(
    sidebarPanel(
      selectInput("cilindros", label = "Selecione o número de cilindros do motor:", choices = sort(unique(mtcars$cyl))),
      selectInput("eixo_x", label = "Selecione a variável do eixo x do gráfico:", choices = names(mtcars)),
      selectInput("eixo_y", label = "Selecione a variável do eixo y do gráfico:", choices = names(mtcars)),
      actionButton(inputId = "atualizar", label = "Atualizar a tabela e o gráfico")
    ),
    mainPanel(
*     tabsetPanel(
        tabPanel(title = "Tabela", tableOutput(outputId = "tabela")),
        tabPanel(title = "Gráfico", plotOutput(outputId = "grafico"))
*     )
    )
  )
)
```

---
class: middle

### tabsetPanel: entendendo o código

A função .codigo[tabsetPanel()] recebe elementos criados pela função .codigo[tabPanel()]. Cada .codigo[tabPanel()] que utilizamos cria uma nova aba na área principal do sidebarLayout. Nesse exemplo, estamos criando duas abas: uma para visualizarmos a tabela, que receberá o nome de "Tabela", e uma para visualizarmos o gráfico, que receberá o nome de "Gráfico".


```r
ui &lt;- fluidPage(
  titlePanel("Um aplicativo usando o tabsetPanel junto do sidebarLayout"),
  hr(),
  sidebarLayout(
    sidebarPanel(
      selectInput("cilindros", label = "Selecione o número de cilindros do motor:", choices = sort(unique(mtcars$cyl))),
      selectInput("eixo_x", label = "Selecione a variável do eixo x do gráfico:", choices = names(mtcars)),
      selectInput("eixo_y", label = "Selecione a variável do eixo y do gráfico:", choices = names(mtcars)),
      actionButton(inputId = "atualizar", label = "Atualizar a tabela e o gráfico")
    ),
    mainPanel(
      tabsetPanel(
*       tabPanel(title = "Tabela", tableOutput(outputId = "tabela")),
*       tabPanel(title = "Gráfico", plotOutput(outputId = "grafico"))
      )
    )
  )
)
```

---
class: middle

### tabsetPanel: entendendo o código

O servidor, novamente, não sofre alterações.


```r
server &lt;- function(input, output, session) {
  mtcars_filtrada &lt;- reactive({
    mtcars |&gt;
      filter(cyl == input$cilindros)
  })
  
  tabela_atualizada &lt;- eventReactive(input$atualizar, {
    mtcars_filtrada()
  })
  
  output$tabela &lt;- renderTable(tabela_atualizada(), rownames = TRUE)
  
  grafico_atualizado &lt;- eventReactive(input$atualizar, {
    mtcars_filtrada() |&gt;
      ggplot(mapping = aes_string(x = input$eixo_x, y = input$eixo_y)) +
      geom_point()
  })
  
  output$grafico &lt;- renderPlot(grafico_atualizado())
}
```


---
class: middle

### navbarPage: um exemplo 

Quando queremos criar um layout com um com menu de navegação superior, utilizamos a função .codigo[navbarPage()]. Adaptando o aplicativo criado anteriormente para esse novo tipo de layout, teríamos o seguinte resultado, que pode ser acessado através [deste link](https://rafaelsherzog.shinyapps.io/06-navbarPage/):

.panelset[

.panel[
.panel-name[Sobre]

.center[
&lt;img src="img/navbarPage1.png" width="95%" style="display: block; margin: auto;" /&gt;
]
]

.panel[
.panel-name[Visualizações]

.center[
&lt;img src="img/navbarPage2.png" width="95%" style="display: block; margin: auto;" /&gt;
]

]

.panel[
.panel-name[Tabela]

.center[
&lt;img src="img/navbarPage3.png" width="95%" style="display: block; margin: auto;" /&gt;
]

]
.panel[
.panel-name[Gráfico]

.center[
&lt;img src="img/navbarPage4.png" width="95%" style="display: block; margin: auto;" /&gt;
]

]
]

---
class: top

### navbarPage: entendendo o código

Tudo aquilo que queremos que esteja na UI deve estar dentro da função .codigo[navbarPage()], diferente do que acontecia com os outros tipos de layout: 


```r
*ui &lt;- navbarPage(
  title = "Utilizando a navbarPage",  
  tabPanel(title = "Sobre"),
  navbarMenu(
    title = "Visualizações",
    tabPanel(title = "Tabela"),
    tabPanel(title = "Gráfico")
  )
*)
```

---
class: top

### navbarPage: entendendo o código

O título do aplicativo é definido através do argumento .codigo[title]:


```r
ui &lt;- navbarPage(
* title = "Utilizando a navbarPage",  
  tabPanel(title = "Sobre"),
  navbarMenu(
    title = "Visualizações",
    tabPanel(title = "Tabela"),
    tabPanel(title = "Gráfico")
  )
)
```

- Resultado:

.center[
&lt;img src="img/navbar-ex1.png" width="100%" style="display: block; margin: auto;" /&gt;
]


---
class: top

### navbarPage: entendendo o código

Criamos cada aba do menu de navegação superior através da função .codigo[tabPanel()]:


```r
ui &lt;- navbarPage(
  title = "Utilizando a navbarPage",  
* tabPanel(title = "Sobre"),
  navbarMenu(
    title = "Visualizações",
    tabPanel(title = "Tabela"),
    tabPanel(title = "Gráfico")
  )
)
```

- Resultado:

.center[
&lt;img src="img/navbar-ex2.png" width="100%" style="display: block; margin: auto;" /&gt;
]


---
class: top

### navbarPage: entendendo o código

Criamos uma aba que agrupará outras páginas por meio da função .codigo[navbarMenu()]:


```r
ui &lt;- navbarPage(
  title = "Utilizando a navbarPage",  
  tabPanel(title = "Sobre"),
* navbarMenu(
    title = "Visualizações",
    tabPanel(title = "Tabela"),
    tabPanel(title = "Gráfico")
* )
)
```

- Resultado:

.center[
&lt;img src="img/navbar-ex3.png" width="100%" style="display: block; margin: auto;" /&gt;
]


---
class: top

### navbarPage: entendendo o código

Criamos cada página que estará agrupada na aba "Visualizações" por meio da função .codigo[tabPanel()]:


```r
ui &lt;- navbarPage(
  title = "Utilizando a navbarPage",  
  tabPanel(title = "Sobre"),
  navbarMenu(
    title = "Visualizações",
*   tabPanel(title = "Tabela"),
*   tabPanel(title = "Gráfico")
  )
)
```

- Resultado:

.center[
&lt;img src="img/navbar-ex4.png" width="100%" style="display: block; margin: auto;" /&gt;
]


---
class: top

### navbarPage: entendendo o código

Os inputs, outputs e qualquer outro elemento da página são colocados dentro do .codigo[tabPanel()] correspondente.


```r
ui &lt;- navbarPage(
  title = "Utilizando a navbarPage",  
* tabPanel(
*   title = "Sobre",
*   "Aqui você pode encontrar informações sobre o painel."
* ),
  navbarMenu(
    title = "Visualizações",
    tabPanel(title = "Tabela"),
    tabPanel(title = "Gráfico")
  )
)
```

- Resultado: 

.center[
&lt;img src="img/navbar-ex5.png" width="100%" style="display: block; margin: auto;" /&gt;
]


---
class: middle

### navbarPage: No <svg aria-hidden="true" role="img" viewBox="0 0 581 512" style="height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:#0A1E3C;overflow:visible;position:relative;"><path d="M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z"/></svg>

Vamos terminar de escrever o código da UI e do servidor desse aplicativo dentro do R.


---
class: inverse, middle, center

## O pacote {shinydashboard} 


---
class: top

### Visão incial e estrutura básica

O .codigo[{shinydasboard}] é um pacote de R que introduz diversas ferramentas para o Shiny. A principal delas é o layout de dashboard. Com um formato simples de código, conseguimos gerar uma UI naturalmente bonita e organizada.

A estrutura básica da UI de um aplicativo Shiny criado por meio do .codigo[{shinydashboard}] é a seguinte:

.panelset[

.panel[
.panel-name[1]

- Por meio da função .codigo[dashboardPage()], definimos que queremos utilizar o layout de dashboard. Ela recebe três funções como argumentos: .codigo[dashboardHeader()], .codigo[dashboardSidebar()] e .codigo[dashboardBody()];

.pull-left[

```r
*ui &lt;- dashboardPage(
  dashboardHeader(),
  dashboardSidebar(),
  dashboardBody()
*)
```
]

.pull-right[
&lt;img src="img/dashboard.png" width="100%" style="display: block; margin: auto;" /&gt;
]
]

.panel[
.panel-name[2]

- Por meio da função .codigo[dashboardHeader()], criamos e controlamos a barra superior (em azul);

.pull-left[

```r
ui &lt;- dashboardPage(
* dashboardHeader(),
  dashboardSidebar(),
  dashboardBody()
)
```
]

.pull-right[
&lt;img src="img/dashboard.png" width="100%" style="display: block; margin: auto;" /&gt;
]
]

.panel[
.panel-name[3]

- Por meio da função .codigo[dashboardSidebar()], criamos e controlamos a barra lateral (em preto). Utlizaremos essa parte do aplicativo para criar um menu contendo as páginas do nosso dashboard;

.pull-left[

```r
ui &lt;- dashboardPage(
  dashboardHeader(),
* dashboardSidebar(),
  dashboardBody()
)
```
]

.pull-right[
&lt;img src="img/dashboard.png" width="100%" style="display: block; margin: auto;" /&gt;
]
]

.panel[
.panel-name[4]

- Por fim, por meio da função .codigo[dashboardBody()], criamos e controlamos a área principal do dashboard (em cinza). É nela que colocaremos os nossos inputs e as nossas visualizações.

.pull-left[

```r
ui &lt;- dashboardPage(
  dashboardHeader(),
  dashboardSidebar(),
* dashboardBody()
)
```
]

.pull-right[
&lt;img src="img/dashboard.png" width="100%" style="display: block; margin: auto;" /&gt;
]
]

]

---
class: top

### A barra superior

Como vimos no slide anterior, é por meio da função .codigo[dashboardHeader()] que criamos e controlamos a barra superior do dashboard. O único argumento que utilizaremos dessa função é o argumento .codigo[title], por meio do qual definimos o título do aplicativo.

.panelset[

.panel[
.panel-name[Código]


```r
ui &lt;- dashboardPage(
* dashboardHeader(title = "Meu título"),
  dashboardSidebar(),
  dashboardBody()
)
```

]

.panel[
.panel-name[Resultado]

&lt;img src="img/dashboard2.png" width="95%" style="display: block; margin: auto;" /&gt;
]

]

---
class: top

### O menu lateral

Para construirmos um menu na barra lateral, utilizamos a função .codigo[sidebarMenu()] dentro da função .codigo[dashboardSidebar()]. Cada item do menu é criado pela função .codigo[menuItem()]. Além de utilizarmos o argumento .codigo[text] para dar nomes a cada item, 
a função .codigo[menuItem()] recebe, também, um argumento chamado .codigo[tabName], que será utilizado para nos referirmos ao item correspondente dentro da função .codigo[dashboardBody].

.panelset[

.panel[
.panel-name[Código]

```r
ui &lt;- dashboardPage(
  dashboardHeader(title = "Meu título"),
* dashboardSidebar(
*   sidebarMenu(
*     menuItem(text = "Página 1", tabName = "pagina1"),
*     menuItem(text = "Página 2", tabName = "pagina2")
*   )
* ),
  dashboardBody()
)
```
]

.panel[
.panel-name[Resultado]
&lt;img src="img/dashboard3.png" width="100%" style="display: block; margin: auto;" /&gt;
]
]

---
class: top

### A área principal do aplicativo

Dentro do .codigo[dashboardBody()], utilizamos a função .codigo[tabItems()] para listar os itens do menu. Utilizamos como argumentos para essa função as funções .codigo[tabItem()], nas quais criaremos cada uma das páginas. Dentro de cada .codigo[tabItem()], utilizaremos o argumento .codigo[tabName] para especificarmos qual das páginas definidas no .codigo[sidebarMenu()] estaremos criando. Todo o código necessário para a construção de cada página deve estar dentro do respectivo .codigo[tabItem()].


.panelset[

.panel[
.panel-name[Código]

```r
ui &lt;- dashboardPage(
  dashboardHeader(title = "Meu título"),
  dashboardSidebar(
    sidebarMenu(
      menuItem(text = "Página 1", tabName = "pagina1"),
      menuItem(text = "Página 2", tabName = "pagina2")
    )
  ),
* dashboardBody(
*   tabItems(
*     tabItem(
*       tabName = "pagina1",
*       "Aqui vem todo o conteúdo da primeira página."),
*     tabItem(
*       tabName = "pagina2",
*       "Aqui vem todo o conteúdo da segunda página.")
*   )
* )
)
```
]

.panel[
.panel-name[Resultado]
&lt;img src="img/dashboard4.png" width="100%" style="display: block; margin: auto;" /&gt;
]
]

---
class: middle

### No <svg aria-hidden="true" role="img" viewBox="0 0 581 512" style="height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:#0A1E3C;overflow:visible;position:relative;"><path d="M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z"/></svg>

Para finalizarmos o minicurso, vamos construir o aplicativo abaixo utilizando o pacote .codigo[{shinydashboard}]. O aplicativo pode ser encontrado [neste link](https://rafasantanah.shinyapps.io/shinydashboard/).

.panelset[

.panel[
.panel-name[Tabela]
&lt;img src="img/dashboard5.png" width="100%" style="display: block; margin: auto;" /&gt;

]

.panel[
.panel-name[Gráfico]
&lt;img src="img/dashboard6.png" width="100%" style="display: block; margin: auto;" /&gt;
]
]

---
class: inverse, middle

.center[
## &lt;br&gt;Obrigado!
]

.pull-left[
&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="img/butantan.png" alt="Foto: OOBr no Instituto Butantan." width="100%" /&gt;
&lt;p class="caption"&gt;Foto: OOBr no Instituto Butantan.&lt;/p&gt;
&lt;/div&gt;
]

.pull-right[
&lt;br&gt;&lt;br&gt;OOBr na web:

<svg aria-hidden="true" role="img" viewBox="0 0 512 512" style="height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:white;overflow:visible;position:relative;"><path d="M352 256C352 278.2 350.8 299.6 348.7 320H163.3C161.2 299.6 159.1 278.2 159.1 256C159.1 233.8 161.2 212.4 163.3 192H348.7C350.8 212.4 352 233.8 352 256zM503.9 192C509.2 212.5 512 233.9 512 256C512 278.1 509.2 299.5 503.9 320H380.8C382.9 299.4 384 277.1 384 256C384 234 382.9 212.6 380.8 192H503.9zM493.4 160H376.7C366.7 96.14 346.9 42.62 321.4 8.442C399.8 29.09 463.4 85.94 493.4 160zM344.3 160H167.7C173.8 123.6 183.2 91.38 194.7 65.35C205.2 41.74 216.9 24.61 228.2 13.81C239.4 3.178 248.7 0 256 0C263.3 0 272.6 3.178 283.8 13.81C295.1 24.61 306.8 41.74 317.3 65.35C328.8 91.38 338.2 123.6 344.3 160H344.3zM18.61 160C48.59 85.94 112.2 29.09 190.6 8.442C165.1 42.62 145.3 96.14 135.3 160H18.61zM131.2 192C129.1 212.6 127.1 234 127.1 256C127.1 277.1 129.1 299.4 131.2 320H8.065C2.8 299.5 0 278.1 0 256C0 233.9 2.8 212.5 8.065 192H131.2zM194.7 446.6C183.2 420.6 173.8 388.4 167.7 352H344.3C338.2 388.4 328.8 420.6 317.3 446.6C306.8 470.3 295.1 487.4 283.8 498.2C272.6 508.8 263.3 512 255.1 512C248.7 512 239.4 508.8 228.2 498.2C216.9 487.4 205.2 470.3 194.7 446.6H194.7zM190.6 503.6C112.2 482.9 48.59 426.1 18.61 352H135.3C145.3 415.9 165.1 469.4 190.6 503.6V503.6zM321.4 503.6C346.9 469.4 366.7 415.9 376.7 352H493.4C463.4 426.1 399.8 482.9 321.4 503.6V503.6z"/></svg> [https://observatorioobstetricobr.org](https://observatorioobstetricobr.org)

<svg aria-hidden="true" role="img" viewBox="0 0 512 512" style="height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:white;overflow:visible;position:relative;"><path d="M459.4 151.7c.325 4.548 .325 9.097 .325 13.65 0 138.7-105.6 298.6-298.6 298.6-59.45 0-114.7-17.22-161.1-47.11 8.447 .974 16.57 1.299 25.34 1.299 49.06 0 94.21-16.57 130.3-44.83-46.13-.975-84.79-31.19-98.11-72.77 6.498 .974 12.99 1.624 19.82 1.624 9.421 0 18.84-1.3 27.61-3.573-48.08-9.747-84.14-51.98-84.14-102.1v-1.299c13.97 7.797 30.21 12.67 47.43 13.32-28.26-18.84-46.78-51.01-46.78-87.39 0-19.49 5.197-37.36 14.29-52.95 51.65 63.67 129.3 105.3 216.4 109.8-1.624-7.797-2.599-15.92-2.599-24.04 0-57.83 46.78-104.9 104.9-104.9 30.21 0 57.5 12.67 76.67 33.14 23.72-4.548 46.46-13.32 66.6-25.34-7.798 24.37-24.37 44.83-46.13 57.83 21.12-2.273 41.58-8.122 60.43-16.24-14.29 20.79-32.16 39.31-52.63 54.25z"/></svg> [@observatorioobr](https://twitter.com/observatorioobr)

<svg aria-hidden="true" role="img" viewBox="0 0 448 512" style="height:1em;width:0.88em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:white;overflow:visible;position:relative;"><path d="M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"/></svg> [@observatorioobr](https://instagram/observatorioobr) 

<svg aria-hidden="true" role="img" viewBox="0 0 512 512" style="height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:white;overflow:visible;position:relative;"><path d="M464 64C490.5 64 512 85.49 512 112C512 127.1 504.9 141.3 492.8 150.4L275.2 313.6C263.8 322.1 248.2 322.1 236.8 313.6L19.2 150.4C7.113 141.3 0 127.1 0 112C0 85.49 21.49 64 48 64H464zM217.6 339.2C240.4 356.3 271.6 356.3 294.4 339.2L512 176V384C512 419.3 483.3 448 448 448H64C28.65 448 0 419.3 0 384V176L217.6 339.2z"/></svg> &lt;a href="mailto:observatorioobstetricobr@gmail.com"&gt;observatorioobstetricobr@gmail.com&lt;/a&gt;
]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
